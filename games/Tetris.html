<div class="card">
  <button class="back-btn" onclick="backMenu()">←</button>
  <canvas id="tetris" width="220" height="440"></canvas>
  <div style="display:flex;gap:10px;align-items:center;margin-top:10px;">
    <button id="tetris-start">▶</button>
    <button id="tetris-restart">⟲</button>
    <span id="tetris-score">0</span>
  </div>
</div>
<script>
function backMenu() {
  document.getElementById('game-container').innerHTML = '';
  document.getElementById('menu').style.display = '';
}
const c = document.getElementById('tetris');
const ctx = c.getContext('2d');
const COLS=10, ROWS=20, CELL=22;
let grid, current, running=false, tickId, score=0;
const shapes=[
[[1,1,1,1]],
[[1,1],[1,1]],
[[0,1,1],[1,1,0]],
[[1,1,0],[0,1,1]],
[[1,0,0],[1,1,1]],
[[0,0,1],[1,1,1]],
[[0,1,0],[1,1,1]]
];
const colors=["#e94e77","#8fd14f","#48b9e9","#f7e94e","#3ac","#b99861","#f99"];
function newPiece(){
  const s=shapes[Math.floor(Math.random()*shapes.length)];
  return {shape:s,x:COLS/2-1,y:0,color:colors[Math.floor(Math.random()*colors.length)]};
}
function reset(){
  grid=Array.from({length:ROWS},()=>Array(COLS).fill(0));
  current=newPiece(); score=0; running=false; document.getElementById('tetris-score').textContent=score; draw();
}
function collide(){
  for(let y=0;y<current.shape.length;y++)
    for(let x=0;x<current.shape[y].length;x++)
      if(current.shape[y][x] && (grid[current.y+y] && grid[current.y+y][current.x+x])!==0)
        return true;
  return false;
}
function merge(){
  for(let y=0;y<current.shape.length;y++)
    for(let x=0;x<current.shape[y].length;x++)
      if(current.shape[y][x]) grid[current.y+y][current.x+x]=current.color;
}
function clearLines(){
  let lines=0;
  for(let y=ROWS-1;y>=0;y--){
    if(grid[y].every(v=>v)){
      grid.splice(y,1); grid.unshift(Array(COLS).fill(0)); lines++;
    }
  }
  score+=lines*10; document.getElementById('tetris-score').textContent=score;
}
function step(){
  if(!running)return;
  current.y++;
  if(collide()){
    current.y--; merge(); clearLines();
    current=newPiece();
    if(collide()){ running=false; drawGameOver(); return; }
  }
  draw();
}
function draw(){
  ctx.fillStyle='#191e29';ctx.fillRect(0,0,c.width,c.height);
  for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)
    if(grid[y][x]){ ctx.fillStyle=grid[y][x];ctx.fillRect(x*CELL,y*CELL,CELL-2,CELL-2);}
  for(let y=0;y<current.shape.length;y++)
    for(let x=0;x<current.shape[y].length;x++)
      if(current.shape[y][x]){ ctx.fillStyle=current.color;ctx.fillRect((current.x+x)*CELL,(current.y+y)*CELL,CELL-2,CELL-2);}
}
function drawGameOver(){
  draw();
  ctx.fillStyle='rgba(0,0,0,0.49)';
  ctx.fillRect(0,0,c.width,c.height);
  ctx.fillStyle='#fff';
  ctx.font='bold 22px system-ui, Arial'; ctx.textAlign='center';
  ctx.fillText('Game Over',c.width/2,c.height/2);
}
document.getElementById('tetris-start').onclick=()=>{if(!running){running=true;tickId=setInterval(step,400);}};
document.getElementById('tetris-restart').onclick=()=>{reset();running=true;tickId=setInterval(step,400);};
window.addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft'){current.x--;if(collide())current.x++;}
  if(e.key==='ArrowRight'){current.x++;if(collide())current.x--;}
  if(e.key==='ArrowDown'){step();}
  if(e.key==='ArrowUp'){ // rotate
    const s=current.shape;const n=[];
    for(let x=0;x<s[0].length;x++)n.push(s.map(r=>r[x]).reverse());
    const old=current.shape;current.shape=n;if(collide())current.shape=old;
  }
  if(e.key==='Escape') backMenu();
  draw();
});
reset();
</script>